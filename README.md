# KernelGatekeeper - Прозрачный Kerberos-прокси на eBPF

KernelGatekeeper - это система, обеспечивающая прозрачную проксификацию TCP-соединений для пользовательских приложений с автоматической аутентификацией через Kerberos (GSSAPI/SPNEGO). Она использует мощь eBPF (в частности, sockops) для перехвата и перенаправления сетевого трафика без необходимости модификации самих приложений или настроек системы (таких как `http_proxy`).

**Основная цель:** Предоставить пользователям и системным процессам бесшовный доступ к ресурсам через HTTP/HTTPS прокси, требующие Kerberos-аутентификацию, используя их собственные учетные данные Kerberos.

## Как это работает

Система состоит из двух основных компонентов:

1.  **Системная служба (`kernelgatekeeper-service`):**
    *   Запускается от имени `root`.
    *   Загружает и управляет eBPF-программами (connect4, sockops, skmsg).
    *   eBPF-программа `connect4` сохраняет информацию об исходящих TCP-соединениях (PID, оригинальный адрес назначения) в BPF map.
    *   eBPF-программа `sockops` срабатывает при установке TCP-соединения процессом пользователя. Она проверяет, соответствует ли порт назначения списку `target_ports` в конфигурации.
    *   Если порт соответствует, `sockops` помещает сокет соединения в `proxy_sock_map` (BPF sockmap) и отправляет уведомление через BPF ring buffer системной службе.
    *   Системная служба получает уведомление, определяет UID процесса по PID и находит соответствующий пользовательский клиент.
    *   Служба отправляет команду `notify_accept` пользовательскому клиенту через сокет UNIX.
    *   eBPF-программа `skmsg` перенаправляет данные из сокета приложения в сокет, связанный с пользовательским клиентом через `proxy_sock_map`.

2.  **Пользовательский клиент (`kernelgatekeeper-client`):**
    *   Запускается от имени обычного пользователя (обычно через systemd user service).
    *   Подключается к системной службе через сокет UNIX (`/var/run/kernelgatekeeper.sock` по умолчанию).
    *   Получает конфигурацию прокси и Kerberos от системной службы.
    *   Инициализирует Kerberos-клиент, используя **учетные данные текущего пользователя** (обычно из ccache, например, `/tmp/krb5cc_UID`).
    *   Прослушивает локальный порт (например, `127.0.0.1:3129`), к которому BPF будет подключать перехваченные сокеты.
    *   При получении команды `notify_accept` от службы, клиент принимает входящее соединение от BPF на своем локальном порту.
    *   Определяет необходимый прокси-сервер (на основе статической конфигурации или PAC-файла).
    *   Устанавливает соединение с прокси-сервером.
    *   Отправляет `CONNECT` запрос к прокси для установления туннеля до оригинального адреса назначения.
    *   При необходимости (если прокси возвращает `407 Proxy Authentication Required`) добавляет заголовок `Proxy-Authorization: Negotiate ...` с SPNEGO-токеном, сгенерированным на основе тикета Kerberos пользователя.
    *   После установления туннеля, клиент просто ретранслирует данные между локальным сокетом (от BPF) и сокетом прокси-сервера.

Таким образом, для приложения пользователя соединение выглядит как прямое, но на самом деле оно проходит через прокси с автоматической Kerberos-аутентификацией.

## Возможности

*   **Прозрачность:** Не требует настройки прокси в приложениях или переменных окружения.
*   **Аутентификация Kerberos:** Автоматически использует тикеты Kerberos пользователя для аутентификации на прокси (SPNEGO).
*   **eBPF Sockops:** Эффективное перенаправление трафика на уровне ядра с минимальными задержками.
*   **Поддержка PAC-файлов:** Может использовать PAC-файл (локальный или по URL) для определения нужного прокси для конкретного URL.
*   **Статическая конфигурация:** Возможность указать прокси-сервер напрямую в конфигурации.
*   **Разделение привилегий:** Служба eBPF работает с повышенными привилегиями, а обработка прокси и Kerberos выполняется в контексте непривилегированного пользовательского процесса.
*   **Минимальные зависимости (для клиента):** Клиентская часть не требует специальных библиотек для работы (кроме стандартных системных для Kerberos).

## Установка

### Использование пакета Debian (.deb) (Рекомендуется)

1.  Соберите пакет (см. секцию "Сборка") или скачайте готовый `.deb` файл для вашей архитектуры.
2.  Установите пакет:
    ```bash
    sudo dpkg -i kernelgatekeeper_<ВЕРСИЯ>_<АРХИТЕКТУРА>.deb
    # Если возникнут проблемы с зависимостями:
    # sudo apt --fix-broken install
    ```
3.  Во время установки:
    *   Будет создан конфигурационный файл `/etc/kernelgatekeeper/config.yaml` (если его не существует).
    *   Будет создана системная служба `kernelgatekeeper.service` и запущена.
    *   Будет установлен пользовательский сервис `kernelgatekeeper-client.service`.
    *   Будет добавлен скрипт в `/etc/profile.d/`, который попытается автоматически включить и запустить `kernelgatekeeper-client.service` при первом входе пользователя в систему (через `systemctl --user enable --now`). *Примечание:* Это может не сработать надежно при самом первом графическом входе после установки.

### Сборка и установка из исходного кода (Для разработки)

**Зависимости для сборки:**

*   Go (>= 1.23)
*   Clang/LLVM (для компиляции eBPF)
*   Заголовочные файлы ядра Linux (пакет `linux-headers-generic` или аналогичный)
*   Библиотека `libbpf` (пакет `libbpf-dev` или аналогичный)
*   Системные утилиты Kerberos (`krb5-user` для `kinit` и библиотек)

**Процесс сборки:**

1.  Клонируйте репозиторий.
2.  Установите зависимости Go:
    ```bash
    make deps
    # или go mod tidy && go mod verify
    ```
3.  Соберите BPF-программы и Go-приложения:
    ```bash
    make
    # или make generate && make build
    ```
    Бинарные файлы появятся в директории `bin/`.

4.  **Ручная установка (для тестирования):**
    ```bash
    sudo make install
    ```
    Эта команда скопирует бинарные файлы, конфигурацию по умолчанию и systemd юниты в стандартные места. После этого необходимо перезагрузить демоны systemd и включить службы:
    ```bash
    sudo systemctl daemon-reload
    systemctl --user daemon-reload
    sudo systemctl enable --now kernelgatekeeper.service
    systemctl --user enable --now kernelgatekeeper-client.service
    ```

## Конфигурация

Основной конфигурационный файл находится по пути `/etc/kernelgatekeeper/config.yaml`.

```yaml
proxy:
  # Тип настройки прокси: "http", "https", "wpad", "none".
  type: wpad
  # URL прокси-сервера (если type="http" или "https").
  # url: "http://proxy.example.com:3128"
  # URL для загрузки wpad.dat/proxy.pac (если type="wpad").
  wpadUrl: "http://wpad.example.com/wpad.dat"
  # Таймаут соединения с прокси (секунды).
  connectionTimeout: 10
  # Таймаут выполнения CONNECT-запроса (секунды).
  requestTimeout: 30
  # Макс. кол-во попыток подключения к прокси.
  maxRetries: 3
  # Кодировка PAC-файла (если не UTF-8).
  pacCharset: ""
  # Таймаут выполнения PAC-скрипта (секунды).
  pacExecutionTimeout: 5

kerberos:
  # Realm Kerberos (не обязательно).
  realm: "EXAMPLE.COM"
  # Адрес KDC (не обязательно, если работает DNS lookup).
  kdcHost: ""
  # Principal (обычно не требуется для клиента).
  principal: ""
  # Путь к keytab (обычно не требуется для клиента).
  keytabPath: ""
  # Использовать ли кэш учетных данных (ccache)?
  enableCache: true
  # Время жизни тикета (для генерации, не используется клиентом).
  ticketLifetime: 24
  # Путь к ccache (не обязательно).
  cachePath: ""

ebpf:
  # Интерфейс для BPF программ (не используется в режиме sockops).
  interface: "eth0"
   # Путь к BPF программам (не используется, если встроены).
  programPath: ""
  # Порты назначения, трафик к которым будет перехватываться.
  targetPorts: [80, 443]
  # Режим загрузки BPF (сейчас только sockops).
  loadMode: "sockops"
  # Разрешать ли клиентам динамически изменять список портов через IPC.
  allowDynamicPorts: true
  # Интервал обновления статистики BPF (секунды).
  statsInterval: 15
  # Размер буфера канала для уведомлений от BPF к сервису.
  notificationChannelSize: 4096
  # Список полных абсолютных путей к исполняемым файлам для исключения из проксирования.
  excluded:
    - "/usr/bin/ssh"
    - "/usr/sbin/sshd"

# Уровень логирования: debug, info, warn, error.
logLevel: "info"
# Путь к лог-файлу службы.
logPath: "/var/log/kernelgatekeeper.log"

# Таймаут для корректного завершения работы (секунды).
shutdownTimeout: 30
# Путь к сокету UNIX для связи между службой и клиентом.
socketPath: "/var/run/kernelgatekeeper.sock"
```

**Важно:** Пользователь, от имени которого запускается `kernelgatekeeper-client`, должен иметь действительный Kerberos TGT (Ticket Granting Ticket), полученный, например, через `kinit` или SSSD. Клиент использует существующий тикет, он не получает его сам.

## Использование и проверка статуса

После установки и настройки система должна работать автоматически.

*   **Проверка статуса системной службы:**
    ```bash
    sudo systemctl status kernelgatekeeper.service
    # Просмотр логов службы:
    sudo journalctl -u kernelgatekeeper.service -f
    # или смотрите /var/log/kernelgatekeeper.log (если настроено)
    ```

*   **Проверка статуса пользовательского клиента:**
    (Выполняется от имени пользователя)
    ```bash
    systemctl --user status kernelgatekeeper-client.service
    # Просмотр логов клиента:
    journalctl --user -u kernelgatekeeper-client.service -f
    ```

*   **Получение информации о работе:**
    Можно использовать клиент для запроса статуса у сервиса (если сервис запущен):
    ```bash
    # Понадобится доступ на чтение/запись к socket_path
    # sudo apt install socat (если не установлен)
    echo '{"command":"get_status"}' | sudo socat - UNIX-CONNECT:/var/run/kernelgatekeeper.sock
    ```

## Лицензия

Код eBPF программ (`pkg/ebpf/bpf/*.c`) распространяется под лицензией **GPL v2.0**.
Остальная часть кода (Go) распространяется под лицензией **MIT** (если не указано иное в исходных файлах). Пожалуйста, проверьте файлы лицензий в репозитории для точной информации.