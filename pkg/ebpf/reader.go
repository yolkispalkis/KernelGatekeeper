package ebpf

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors" // Added import
	"log/slog"
	"os"
	"time"

	"github.com/cilium/ebpf/ringbuf" // Added import

	"github.com/yolkispalkis/kernelgatekeeper/pkg/bpfutil"
	"github.com/yolkispalkis/kernelgatekeeper/pkg/common"
)

// BpfNotificationTupleT should ideally be imported from the bpf2go generated file.
// Example: type BpfNotificationTupleT bpf_sockopsNotificationTupleT (replace bpf_sockops with actual generator name)
// We keep the manual definition for now if the exact generated name isn't known,
// but using the generated type directly is preferred.
func (m *BPFManager) readNotifications(ctx context.Context) {
	var bpfTuple BpfNotificationTupleT // Use the type defined in types.go or generated by bpf2go
	tupleSize := binary.Size(bpfTuple) // Use binary.Size for safety
	if tupleSize <= 0 {
		slog.Error("Could not determine size of BpfNotificationTupleT", "size", tupleSize)
		return
	}
	slog.Debug("BPF ring buffer reader expecting record size", "size", tupleSize)

	for {
		select {
		case <-ctx.Done():
			slog.Info("Stopping BPF ring buffer reader due to context cancellation.")
			return
		case <-m.stopChan:
			slog.Info("Stopping BPF ring buffer reader due to stop signal.")
			return
		default:
		}
		// Use the imported ringbuf package
		record, err := m.notificationReader.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) || errors.Is(err, os.ErrClosed) {
				slog.Info("BPF ring buffer reader closed.")
				return
			}
			if errors.Is(err, context.Canceled) {
				slog.Info("BPF ring buffer reading cancelled by context.")
				return
			}
			slog.Error("Error reading from BPF ring buffer", "error", err)
			// Add a small delay before retrying on non-closing errors
			select {
			case <-time.After(100 * time.Millisecond):
				continue
			case <-ctx.Done():
				return
			case <-m.stopChan:
				return
			}
		}
		slog.Debug("Received raw BPF ring buffer record", "len", len(record.RawSample))

		if len(record.RawSample) < tupleSize {
			slog.Warn("Received BPF ring buffer event with unexpected size, skipping.", "expected_min", tupleSize, "received", len(record.RawSample))
			continue
		}

		reader := bytes.NewReader(record.RawSample)
		// Use binary.Read with the correct struct type. Assuming NativeEndian is appropriate for kernel struct layout.
		if err := binary.Read(reader, common.NativeEndian, &bpfTuple); err != nil { // Use common.NativeEndian
			slog.Error("Failed to decode BPF ring buffer event data into BpfNotificationTupleT", "error", err)
			continue
		}

		// Convert from BPF struct format to Go application format
		event := NotificationTuple{
			PidTgid:     bpfTuple.PidTgid,
			SrcIP:       bpfutil.IpFromInt(bpfTuple.SrcIp),     // Convert BigEndian IP
			OrigDstIP:   bpfutil.IpFromInt(bpfTuple.OrigDstIp), // Convert BigEndian IP
			SrcPort:     bpfutil.Ntohs(bpfTuple.SrcPort),       // Convert Network to Host short
			OrigDstPort: bpfutil.Ntohs(bpfTuple.OrigDstPort),   // Convert Network to Host short
			Protocol:    bpfTuple.Protocol,                     // Protocol is likely already fine
		}

		select {
		case m.notificationChannel <- event:
			slog.Debug("Sent BPF connection notification to service processor", "pid_tgid", event.PidTgid, "src_ip", event.SrcIP, "src_port", event.SrcPort, "orig_dst_ip", event.OrigDstIP, "orig_dst_port", event.OrigDstPort)
		case <-ctx.Done():
			slog.Info("Stopping BPF ring buffer reader while sending notification (context cancelled).")
			return
		case <-m.stopChan:
			slog.Info("Stopping BPF ring buffer reader while sending notification (stop signal).")
			return
		default:
			// Avoid blocking if the channel is full
			slog.Warn("BPF notification channel is full, dropping event.", "channel_cap", cap(m.notificationChannel), "channel_len", len(m.notificationChannel), "event_dst_port", event.OrigDstPort)
		}
	}
}
