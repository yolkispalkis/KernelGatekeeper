// pkg/ebpf/program.go
package ebpf

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"log/slog"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"

	"github.com/yolki/kernelgatekeeper/pkg/config"
)

//go:generate go run -tags linux github.com/cilium/ebpf/cmd/bpf2go -cc clang -target bpf -cflags "-O2 -g -Wall -Werror -DDEBUG -I./bpf -I/usr/include/bpf -I/usr/include" bpf_sockops ./bpf/sockops.c -- -I./bpf
//go:generate go run -tags linux github.com/cilium/ebpf/cmd/bpf2go -cc clang -target bpf -cflags "-O2 -g -Wall -Werror -DDEBUG -I./bpf -I/usr/include/bpf -I/usr/include" bpf_skmsg ./bpf/skmsg.c -- -I./bpf

// Constants related to BPF map keys and Cgroup path
const (
	// GlobalStatsMatchedIndex is the key in the global_stats map for connections matched by sockops.
	GlobalStatsMatchedIndex = 1 // Key 0 might be used for total, Key 1 for matched (as per sockops.c example)
	// DefaultCgroupPath is the standard path for the cgroup v2 filesystem root.
	DefaultCgroupPath = "/sys/fs/cgroup"
)

// GlobalStats holds aggregated packet and byte counts.
type GlobalStats struct {
	Packets uint64
	Bytes   uint64 // Note: Bytes are currently NOT collected by the BPF programs.
}

// NotificationTuple holds information about a connection intercepted by BPF sockops.
type NotificationTuple struct {
	SrcIP    net.IP // Source IP address (IPv4 or IPv6) - // TODO IPv6: Ensure this handles IPv6 correctly after BPF changes
	DstIP    net.IP // Destination IP address (IPv4 or IPv6) - // TODO IPv6: Ensure this handles IPv6 correctly after BPF changes
	SrcPort  uint16 // Source port
	DstPort  uint16 // Destination port
	Protocol uint8  // IP protocol (e.g., syscall.IPPROTO_TCP)
	// TODO IPv6: Add Family field (AF_INET or AF_INET6)
}

// BpfConnectionStateT corresponds to struct connection_state_t in bpf_shared.h
// It holds the PID/TGID associated with a connection tuple.
type BpfConnectionStateT = bpf_sockopsConnectionStateT // Using generated type

// BpfConnectionTupleT corresponds to struct connection_tuple_t in bpf_shared.h
// It holds the 5-tuple identifying a connection.
type BpfConnectionTupleT = bpf_sockopsConnectionTupleT // Using generated type

// bpfObjects holds references to the loaded eBPF programs and maps.
// This struct is generated by bpf2go based on the maps and programs defined in the C code.
type bpfObjects struct {
	bpf_sockopsObjects // Embeds programs and maps from sockops generation
	bpf_skmsgObjects   // Embeds programs and maps from skmsg generation
}

// Close releases all resources associated with the bpfObjects.
func (o *bpfObjects) Close() error {
	// Close methods are generated by bpf2go on the embedded types
	errSockops := o.bpf_sockopsObjects.Close()
	errSkmsg := o.bpf_skmsgObjects.Close()

	// Combine errors if both fail
	if errSockops != nil && errSkmsg != nil {
		return fmt.Errorf("failed closing sockops (%v) and skmsg (%v) objects", errSockops, errSkmsg)
	}
	if errSockops != nil {
		return fmt.Errorf("failed to close sockops objects: %w", errSockops)
	}
	return errSkmsg // Return skmsg error if sockops closed fine, or nil if both ok
}

// BPFManager encapsulates the logic for loading, attaching, and interacting with the eBPF programs.
type BPFManager struct {
	cfg                 *config.EBPFConfig
	objs                bpfObjects
	cgroupLink          link.Link // Link for the sockops program attached to cgroup
	skMsgLink           link.Link // Link for the sk_msg program attached to the sockmap
	notificationReader  *ringbuf.Reader
	notificationChannel chan<- NotificationTuple // Channel to send notifications to the service (write-only view)
	stopOnce            sync.Once                // Ensures Close actions run only once
	stopChan            chan struct{}            // Signals background goroutines to stop
	statsCache          struct {                 // Cached statistics
		sync.RWMutex
		matchedConns  GlobalStats // Last read value for matched connections
		lastMatched   GlobalStats // Previous value for rate calculation
		lastStatsTime time.Time   // Timestamp of the last stats update
	}
	mu sync.Mutex // Protects manager state during init and updates
}

// NewBPFManager creates, loads, and attaches the eBPF programs.
func NewBPFManager(cfg *config.EBPFConfig, notifChan chan<- NotificationTuple) (*BPFManager, error) {
	slog.Info("Initializing BPF Manager", "mode", "sockops/skmsg")

	// Required: Remove memory lock limits for eBPF map creation.
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock rlimit: %w", err)
	}

	// Load eBPF specs generated by bpf2go
	specSockops, err := loadBpf_sockops()
	if err != nil {
		return nil, fmt.Errorf("failed to load sockops BPF specification: %w", err)
	}
	specSkmsg, err := loadBpf_skmsg()
	if err != nil {
		return nil, fmt.Errorf("failed to load skmsg BPF specification: %w", err)
	}

	var objs bpfObjects
	opts := &ebpf.CollectionOptions{
		Maps: ebpf.MapOptions{
			// PinPath: "/sys/fs/bpf/kernelgatekeeper", // Optional: Pin maps for external inspection/reuse
		},
		Programs: ebpf.ProgramOptions{
			LogLevel: ebpf.LogLevelInstruction,        // Provides verifier output on failure
			LogSize:  ebpf.DefaultVerifierLogSize * 8, // Increase log size
		},
	}

	// Load sockops programs and maps first
	if err := specSockops.LoadAndAssign(&objs.bpf_sockopsObjects, opts); err != nil {
		handleVerifierError("sockops", err)
		return nil, fmt.Errorf("failed to load eBPF sockops objects: %w", err)
	}
	slog.Debug("eBPF sockops objects loaded successfully.")

	// Load skmsg program, potentially reusing maps loaded by sockops spec
	if err := specSkmsg.LoadAndAssign(&objs.bpf_skmsgObjects, opts); err != nil {
		handleVerifierError("skmsg", err)
		objs.bpf_sockopsObjects.Close() // Clean up already loaded objects
		return nil, fmt.Errorf("failed to load eBPF skmsg objects: %w", err)
	}
	slog.Debug("eBPF skmsg objects loaded successfully.")

	// Create the manager instance
	manager := &BPFManager{
		cfg:                 cfg,
		objs:                objs,
		notificationChannel: notifChan,
		stopChan:            make(chan struct{}),
	}
	manager.statsCache.lastStatsTime = time.Now() // Initialize stats time

	// Validate that required programs and maps were loaded
	if objs.KernelgatekeeperSockops == nil || objs.KernelgatekeeperSkmsg == nil || objs.ProxySockMap == nil || objs.NotificationRingbuf == nil || objs.ConnectionMap == nil || objs.TargetPorts == nil || objs.GlobalStats == nil {
		objs.Close() // Clean up partially loaded objects
		return nil, errors.New("one or more required BPF programs or maps failed to load (check C code and bpf2go output)")
	}

	// Attach the loaded programs
	if err := manager.attachPrograms(DefaultCgroupPath, objs.KernelgatekeeperSockops, objs.KernelgatekeeperSkmsg, objs.ProxySockMap); err != nil {
		manager.Close() // Clean up loaded objects if attach fails
		return nil, err // Error already contains context
	}

	// Create a reader for the ring buffer map used for notifications
	var ringbufErr error
	manager.notificationReader, ringbufErr = ringbuf.NewReader(objs.NotificationRingbuf)
	if ringbufErr != nil {
		manager.Close() // Clean up
		return nil, fmt.Errorf("failed to create ring buffer reader: %w", ringbufErr)
	}
	slog.Info("BPF ring buffer reader initialized")

	// Set the initial target ports in the BPF map based on config
	if err := manager.UpdateTargetPorts(cfg.TargetPorts); err != nil {
		manager.Close() // Clean up
		return nil, fmt.Errorf("failed to set initial target ports in BPF map: %w", err)
	}

	slog.Info("BPF Manager initialized and programs attached successfully.")
	return manager, nil
}

// handleVerifierError checks if an error is a VerifierError and logs its details.
func handleVerifierError(objType string, err error) {
	var verr *ebpf.VerifierError
	if errors.As(err, &verr) {
		// Print detailed verifier error log
		slog.Error(fmt.Sprintf("eBPF Verifier error (loading %s objects)", objType), "log", fmt.Sprintf("%+v", verr))
	}
}

// attachPrograms attaches the sockops program to the cgroup and the sk_msg program to the sockmap.
func (m *BPFManager) attachPrograms(cgroupPath string, sockopsProg *ebpf.Program, skmsgProg *ebpf.Program, sockMap *ebpf.Map) error {
	// Validate inputs
	if sockopsProg == nil {
		return errors.New("cannot attach nil sock_ops program")
	}
	if skmsgProg == nil {
		return errors.New("cannot attach nil sk_msg program")
	}
	if sockMap == nil {
		return errors.New("cannot attach sk_msg program to nil sockmap")
	}

	// Check cgroup path existence and type
	fi, err := os.Stat(cgroupPath)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("cgroup v2 path '%s' does not exist", cgroupPath)
		}
		return fmt.Errorf("failed to stat cgroup v2 path '%s': %w", cgroupPath, err)
	}
	if !fi.IsDir() {
		return fmt.Errorf("cgroup v2 path '%s' is not a directory", cgroupPath)
	}

	// Attach sock_ops program to the root cgroup v2
	cgroupLink, err := link.AttachCgroup(link.CgroupOptions{
		Path:    cgroupPath,
		Program: sockopsProg,
		Attach:  ebpf.AttachCGroupSockOps,
	})
	if err != nil {
		return fmt.Errorf("failed to attach sock_ops program to cgroup '%s': %w", cgroupPath, err)
	}
	m.cgroupLink = cgroupLink
	slog.Info("eBPF sock_ops program attached to cgroup", "path", cgroupPath)

	// Attach sk_msg program to the sockmap
	skMsgLink, err := link.AttachRawLink(link.RawLinkOptions{
		Program: skmsgProg,
		Attach:  ebpf.AttachSkMsgVerdict,
		Target:  sockMap.FD(),
		Flags:   0,
	})
	if err != nil {
		m.cgroupLink.Close()
		m.cgroupLink = nil
		return fmt.Errorf("failed to attach sk_msg program to proxy_sock_map (FD %d): %w", sockMap.FD(), err)
	}
	m.skMsgLink = skMsgLink
	slog.Info("eBPF sk_msg program attached to proxy_sock_map", "map_fd", sockMap.FD())

	return nil
}

// Start launches the background goroutines for reading notifications and updating stats.
func (m *BPFManager) Start(ctx context.Context, wg *sync.WaitGroup) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.notificationReader == nil {
		return errors.New("BPF manager not fully initialized, cannot start tasks")
	}

	slog.Info("Starting BPF Manager background tasks (ring buffer reader, stats updater)...")

	// Start Ring Buffer Reader Goroutine
	wg.Add(1)
	go func() {
		defer wg.Done()
		slog.Info("BPF ring buffer reader task started.")
		m.readNotifications(ctx)
		slog.Info("BPF ring buffer reader task stopped.")
	}()

	// Start Statistics Updater Goroutine
	wg.Add(1)
	go func() {
		defer wg.Done()
		slog.Info("BPF statistics updater task started.")
		m.statsUpdater(ctx)
		slog.Info("BPF statistics updater task stopped.")
	}()

	return nil
}

// readNotifications continuously reads connection notification events from the BPF ring buffer.
func (m *BPFManager) readNotifications(ctx context.Context) {
	// Determine the expected size of the C struct for validation.
	// TODO IPv6: This size will change when the C struct is updated for IPv6.
	var bpfTuple BpfConnectionTupleT
	tupleSize := binary.Size(bpfTuple)
	if tupleSize < 0 {
		slog.Error("Could not determine size of bpfConnectionTupleT (binary.Size failed)")
		return
	}

	for {
		select { // Check for cancellation signals *before* blocking read
		case <-ctx.Done():
			slog.Info("Stopping BPF ring buffer reader due to context cancellation.")
			return
		case <-m.stopChan:
			slog.Info("Stopping BPF ring buffer reader due to stop signal.")
			return
		default: // Continue if no signal received
		}

		record, err := m.notificationReader.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) || errors.Is(err, os.ErrClosed) {
				slog.Info("BPF ring buffer reader closed.")
				return
			}
			if errors.Is(err, context.Canceled) { // Check if context was cancelled during read
				slog.Info("BPF ring buffer reading cancelled by context.")
				return
			}
			slog.Error("Error reading from BPF ring buffer", "error", err)
			select { // Avoid tight loop on errors
			case <-time.After(500 * time.Millisecond):
				continue
			case <-ctx.Done():
				return // Check context during delay
			case <-m.stopChan:
				return // Check stop signal during delay
			}
		}

		// Process the received record data
		if len(record.RawSample) < tupleSize {
			slog.Warn("Received BPF ring buffer event with unexpected size", "expected_min", tupleSize, "received", len(record.RawSample))
			continue
		}

		// Decode the raw bytes into the Go struct
		// TODO IPv6: Decoding needs update for IPv6 struct layout.
		if err := binary.Read(bytes.NewReader(record.RawSample), nativeEndian, &bpfTuple); err != nil {
			slog.Error("Failed to decode BPF ring buffer event data", "error", err)
			continue
		}

		// Convert BPF data to the NotificationTuple
		event := NotificationTuple{
			// TODO IPv6: Use ipFromBytes(bpfTuple.SrcIp6[:]) or similar.
			SrcIP:    ipFromInt(bpfTuple.SrcIp), // Assumes __be32 network byte order
			DstIP:    ipFromInt(bpfTuple.DstIp), // Assumes __be32 network byte order
			SrcPort:  ntohs(bpfTuple.SrcPort),   // Assumes __be16 network byte order
			DstPort:  ntohs(bpfTuple.DstPort),   // Assumes __be16 network byte order
			Protocol: bpfTuple.Protocol,
			// TODO IPv6: Populate event.Family
		}

		// Send the decoded event to the notification channel (non-blocking).
		select {
		case m.notificationChannel <- event:
			slog.Debug("Sent BPF connection notification to service processor", "src_ip", event.SrcIP, "dst_ip", event.DstIP, "dst_port", event.DstPort)
		case <-ctx.Done(): // Check context cancellation during send attempt
			slog.Info("Stopping BPF ring buffer reader while sending notification (context cancelled).")
			return
		case <-m.stopChan: // Check stop signal during send attempt
			slog.Info("Stopping BPF ring buffer reader while sending notification (stop signal).")
			return
		default:
			// This indicates the service's processing loop is falling behind.
			slog.Warn("BPF notification channel is full, dropping event.", "channel_cap", cap(m.notificationChannel), "channel_len", len(m.notificationChannel), "event_dst_port", event.DstPort)
		}
	}
}

// statsUpdater periodically fetches and logs BPF statistics.
func (m *BPFManager) statsUpdater(ctx context.Context) {
	if m.cfg.StatsInterval <= 0 {
		slog.Info("BPF statistics collection disabled (stats_interval <= 0).")
		return
	}
	interval := time.Duration(m.cfg.StatsInterval) * time.Second
	if interval <= 0 { // Sanity check
		interval = 15 * time.Second
	}
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return // Exit if main context cancelled
		case <-m.stopChan:
			return // Exit if manager stop signal received
		case <-ticker.C:
			if err := m.updateAndLogStats(); err != nil {
				// Log error but continue trying to update stats
				slog.Error("Failed to update BPF statistics", "error", err)
			}
		}
	}
}

// updateAndLogStats reads the current BPF stats, calculates rates, and logs them.
func (m *BPFManager) updateAndLogStats() error {
	m.statsCache.Lock() // Lock for writing to cache
	defer m.statsCache.Unlock()

	now := time.Now()
	duration := now.Sub(m.statsCache.lastStatsTime).Seconds()
	if duration <= 0.1 { // Avoid division by zero or tiny intervals
		slog.Debug("Skipping stats update, interval too short", "duration", duration)
		return nil
	}

	// Read current matched connection stats from BPF map
	matchedCurrent, err := m.readGlobalStats(GlobalStatsMatchedIndex)
	if err != nil {
		return fmt.Errorf("failed to read matched BPF stats: %w", err)
	}

	// Calculate rate per second
	matchedRateP := float64(matchedCurrent.Packets-m.statsCache.lastMatched.Packets) / duration
	// matchedRateB := float64(matchedCurrent.Bytes-m.statsCache.lastMatched.Bytes) / duration // Bytes not currently collected

	slog.Info("eBPF Statistics (SockOps)",
		slog.Group("matched_conns",
			"total_conns", matchedCurrent.Packets,
			"conn_rate_per_sec", fmt.Sprintf("%.2f", matchedRateP),
			// "total_bytes", matchedCurrent.Bytes, // Bytes not currently collected
			// "byte_rate_per_sec", fmt.Sprintf("%.2f", matchedRateB), // Bytes not currently collected
		),
		"interval_sec", fmt.Sprintf("%.2f", duration),
	)

	// Update cache for next calculation
	m.statsCache.matchedConns = matchedCurrent // Store current as the latest known value
	m.statsCache.lastMatched = matchedCurrent  // Store current as the 'previous' value for the *next* interval
	m.statsCache.lastStatsTime = now

	return nil
}

// readGlobalStats reads per-CPU stats from the BPF map and aggregates them.
func (m *BPFManager) readGlobalStats(index uint32) (GlobalStats, error) {
	var aggregate GlobalStats

	if m.objs.GlobalStats == nil {
		return aggregate, errors.New("BPF global_stats map is nil (was it loaded?)")
	}

	// BPF_MAP_TYPE_PERCPU_ARRAY requires reading the per-CPU values.
	// The value type in Go should be a slice of the BPF map value type.
	// bpf2go generates bpf_sockopsGlobalStatsT for the map value.
	var perCPUValues []bpf_sockopsGlobalStatsT

	// Lookup typically returns ErrKeyNotExist if key is out of bounds for array type.
	err := m.objs.GlobalStats.Lookup(index, &perCPUValues)
	if err != nil {
		// Distinguish between key not existing and other errors
		if errors.Is(err, ebpf.ErrKeyNotExist) {
			return aggregate, fmt.Errorf("stats key %d not found in BPF global_stats map: %w", index, err)
		}
		return aggregate, fmt.Errorf("failed lookup stats key %d in BPF global_stats map: %w", index, err)
	}

	// Sum values from all CPUs
	for _, cpuStat := range perCPUValues {
		aggregate.Packets += cpuStat.Packets
		aggregate.Bytes += cpuStat.Bytes // Summing bytes even if BPF doesn't update them
	}
	return aggregate, nil
}

// UpdateTargetPorts updates the target_ports BPF hash map with the provided list of ports.
func (m *BPFManager) UpdateTargetPorts(ports []int) error {
	m.mu.Lock() // Lock to prevent concurrent updates
	defer m.mu.Unlock()

	if m.objs.TargetPorts == nil {
		return errors.New("BPF target_ports map not initialized (was it loaded?)")
	}

	// 1. Get current ports from the BPF map
	currentPortsMap := make(map[uint16]bool)
	var mapKey uint16
	var mapValue uint8 // Value is uint8 in C code
	iter := m.objs.TargetPorts.Iterate()
	for iter.Next(&mapKey, &mapValue) {
		// Check if value indicates presence (e.g., value is 1)
		if mapValue == 1 {
			currentPortsMap[mapKey] = true
		}
	}
	// Check for iteration errors after the loop
	if err := iter.Err(); err != nil {
		// Log warning but proceed, assuming map might be empty or partially iterable
		slog.Warn("Failed to iterate existing BPF target_ports map, proceeding with update anyway", "error", err)
		// Reset map to ensure we add all desired ports
		currentPortsMap = make(map[uint16]bool)
	}

	// 2. Create a set of desired ports from the input list
	desiredPortsSet := make(map[uint16]bool)
	validNewPortsList := make([]int, 0, len(ports)) // For logging the final list
	for _, p := range ports {
		if p > 0 && p <= 65535 {
			portN := uint16(p) // Target key type is u16
			desiredPortsSet[portN] = true
			validNewPortsList = append(validNewPortsList, p)
		} else {
			slog.Warn("Invalid port number ignored in UpdateTargetPorts", "port", p)
		}
	}

	// 3. Delete ports from BPF map that are no longer desired
	deletedCount := 0
	for portKey := range currentPortsMap {
		if !desiredPortsSet[portKey] {
			// Port exists in map but not in the new desired list, delete it.
			if err := m.objs.TargetPorts.Delete(portKey); err != nil {
				// Log error if deletion fails (unless key already gone)
				if !errors.Is(err, ebpf.ErrKeyNotExist) {
					slog.Error("Failed to delete target port from BPF map", "port", portKey, "error", err)
					// Consider returning error here? Or just log? Log for now.
				}
				// else: Key didn't exist, which is fine if deleting.
			} else {
				slog.Debug("Deleted target port from BPF map", "port", portKey)
				deletedCount++
			}
		}
	}

	// 4. Add ports to BPF map that are newly desired
	addedCount := 0
	var mapValueOne uint8 = 1 // Value to indicate presence
	for portKey := range desiredPortsSet {
		if !currentPortsMap[portKey] {
			// Port is in desired list but not currently in the map, add it.
			if err := m.objs.TargetPorts.Put(portKey, mapValueOne); err != nil {
				slog.Error("Failed to add target port to BPF map", "port", portKey, "error", err)
				// Consider returning error here? Or just log? Log for now.
			} else {
				slog.Debug("Added target port to BPF map", "port", portKey)
				addedCount++
			}
		}
	}

	// Log summary of changes
	if addedCount > 0 || deletedCount > 0 {
		slog.Info("BPF target ports map updated", "added", addedCount, "deleted", deletedCount, "final_list", validNewPortsList)
	} else {
		slog.Debug("BPF target ports map unchanged", "ports", validNewPortsList)
	}

	// Update the config struct field to reflect the actual applied state
	// This assumes the caller might want the cfg object updated.
	// Note: This modifies the cfg passed during NewBPFManager initialization.
	m.cfg.TargetPorts = validNewPortsList

	return nil
}

// GetConnectionPID looks up the PID associated with a connection tuple in the BPF map.
func (m *BPFManager) GetConnectionPID(tuple NotificationTuple) (uint32, error) {
	// No lock needed for map lookup as it's thread-safe.

	if m.objs.ConnectionMap == nil {
		return 0, errors.New("BPF connection_map not initialized (was it loaded?)")
	}

	// Construct the BPF map key from the notification tuple.
	// TODO IPv6: Key construction needs update for IPv6 struct layout.
	key := BpfConnectionTupleT{
		// Ensure IPs are in network byte order (BigEndian) for lookup, matching BPF struct.
		// ipFromInt already returns in network byte order (BigEndian).
		SrcIp:    binary.BigEndian.Uint32(tuple.SrcIP.To4()),
		DstIp:    binary.BigEndian.Uint32(tuple.DstIP.To4()),
		SrcPort:  htons(tuple.SrcPort), // Convert host order port back to network order (__be16)
		DstPort:  htons(tuple.DstPort), // Convert host order port back to network order (__be16)
		Protocol: tuple.Protocol,
		// TODO IPv6: Use byte arrays for IPs and set Family field.
	}

	var state BpfConnectionStateT // Value type from BPF map
	err := m.objs.ConnectionMap.Lookup(&key, &state)
	if err != nil {
		if errors.Is(err, ebpf.ErrKeyNotExist) {
			// This is common if the process exits very quickly after connect()
			return 0, fmt.Errorf("connection state not found in BPF map for tuple %+v: %w", tuple, err)
		}
		// Other lookup errors
		return 0, fmt.Errorf("failed to lookup connection state in BPF map for tuple %+v: %w", tuple, err)
	}

	// Extract PID from the PID/TGID field (lower 32 bits).
	pid := uint32(state.PidTgid & 0xFFFFFFFF)
	if pid == 0 {
		// This shouldn't happen if the entry exists, but check defensively.
		return 0, fmt.Errorf("found connection state in BPF map but PID is zero for tuple %+v", tuple)
	}

	slog.Debug("Found PID for connection tuple in BPF map", "tuple", tuple, "pid_tgid", state.PidTgid, "pid", pid)
	return pid, nil
}

// GetStats returns the cached statistics read periodically from the BPF maps.
func (m *BPFManager) GetStats() (total GlobalStats, matched GlobalStats, err error) {
	m.statsCache.RLock() // Lock for reading cache
	defer m.statsCache.RUnlock()

	// Note: Total stats (key 0) are not currently collected/read. Return empty.
	total = GlobalStats{}
	// Return the last read value for matched connections.
	matched = m.statsCache.matchedConns

	return total, matched, nil
}

// Close cleans up all BPF resources: detaches programs and closes maps and links.
func (m *BPFManager) Close() error {
	m.mu.Lock() // Lock to prevent state changes during close
	defer m.mu.Unlock()

	var firstErr error
	m.stopOnce.Do(func() {
		slog.Info("Closing BPF Manager...")
		// 1. Signal background goroutines to stop
		close(m.stopChan)

		// 2. Close ring buffer reader (unblocks reader goroutine)
		if m.notificationReader != nil {
			slog.Debug("Closing BPF ring buffer reader...")
			if err := m.notificationReader.Close(); err != nil && !errors.Is(err, os.ErrClosed) {
				slog.Error("Error closing BPF ringbuf reader", "error", err)
				if firstErr == nil {
					firstErr = fmt.Errorf("ringbuf close: %w", err)
				}
			}
			m.notificationReader = nil // Prevent double close
		}

		// 3. Detach/close links (order might matter, detach from sockmap first?)
		if m.skMsgLink != nil {
			slog.Debug("Closing BPF sk_msg link...")
			if err := m.skMsgLink.Close(); err != nil {
				slog.Error("Error closing BPF sk_msg link", "error", err)
				if firstErr == nil {
					firstErr = fmt.Errorf("sk_msg link close: %w", err)
				}
			}
			m.skMsgLink = nil // Prevent double close
		}
		if m.cgroupLink != nil {
			slog.Debug("Closing BPF cgroup link...")
			if err := m.cgroupLink.Close(); err != nil {
				slog.Error("Error closing BPF cgroup link", "error", err)
				if firstErr == nil {
					firstErr = fmt.Errorf("cgroup link close: %w", err)
				}
			}
			m.cgroupLink = nil // Prevent double close
		}

		// 4. Close all loaded BPF objects (programs and maps)
		slog.Debug("Closing BPF objects (programs and maps)...")
		if err := m.objs.Close(); err != nil {
			slog.Error("Error closing BPF objects", "error", err)
			if firstErr == nil {
				firstErr = fmt.Errorf("bpf objects close: %w", err)
			}
		}
		// Zero out the objects struct? Not strictly necessary after close.
		// m.objs = bpfObjects{}

		slog.Info("BPF Manager closed.")
	})
	return firstErr
}

// --- Utility Functions ---

// nativeEndian stores the system's byte order, determined at init.
var nativeEndian binary.ByteOrder
var errClosed = errors.New("reader closed") // Sentinel error for ringbuf reader closing

// init determines the native byte order of the host system.
func init() {
	buf := [2]byte{}
	// Write a known 16-bit value to the buffer pointer.
	*(*uint16)(unsafe.Pointer(&buf[0])) = 0xABCD
	switch buf {
	case [2]byte{0xCD, 0xAB}: // Little Endian (e.g., x86) stores LSB first
		nativeEndian = binary.LittleEndian
	case [2]byte{0xAB, 0xCD}: // Big Endian stores MSB first
		nativeEndian = binary.BigEndian
	default:
		panic("Failed to determine native byte order")
	}
}

// ipFromInt converts a uint32 representing an IPv4 address in network byte order (BigEndian)
// into a net.IP object.
func ipFromInt(ipInt uint32) net.IP {
	ip := make(net.IP, 4)
	// binary.BigEndian works correctly regardless of nativeEndian,
	// as it explicitly reads/writes in BigEndian order.
	binary.BigEndian.PutUint32(ip, ipInt)
	return ip
}

// TODO IPv6: Add ipFromBytes function:
// func ipFromBytes(ipBytes []byte) net.IP {
// 	if len(ipBytes) == 16 {
// 		return net.IP(ipBytes)
// 	}
// 	if len(ipBytes) == 4 { // Handle IPv4-mapped IPv6 potentially?
//      // Or just return net.IP(ipBytes)? Need to align with BPF struct.
// 		return net.IP(ipBytes)
// 	}
// 	return nil // Invalid length
// }

// ntohs converts a uint16 from network byte order (Big Endian) to host byte order.
func ntohs(n uint16) uint16 {
	// Check if host order is different from network order (Big Endian)
	if nativeEndian == binary.LittleEndian {
		// Swap bytes
		return (n >> 8) | (n << 8)
	}
	// If host order is Big Endian, no swap needed
	return n
}

// htons converts a uint16 from host byte order to network byte order (Big Endian).
func htons(n uint16) uint16 {
	// Check if host order is different from network order (Big Endian)
	if nativeEndian == binary.LittleEndian {
		// Swap bytes
		return (n >> 8) | (n << 8)
	}
	// If host order is Big Endian, no swap needed
	return n
}

// GetAvailableInterfaces lists suitable network interfaces for potential monitoring/stats.
// Note: Sockops attaches to cgroup, not a specific interface, but this can be useful info.
func GetAvailableInterfaces() ([]string, error) {
	interfaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("failed to list network interfaces: %w", err)
	}

	var names []string
	for _, i := range interfaces {
		// Skip down, loopback, and virtual interfaces
		if (i.Flags&net.FlagUp == 0) || (i.Flags&net.FlagLoopback != 0) {
			continue
		}
		// Simple filter for common virtual interface prefixes
		if strings.HasPrefix(i.Name, "veth") || strings.HasPrefix(i.Name, "docker") || strings.HasPrefix(i.Name, "br-") || strings.HasPrefix(i.Name, "lo") {
			continue
		}
		// Check if interface has usable IP addresses (optional, but good)
		addrs, err := i.Addrs()
		if err != nil || len(addrs) == 0 {
			continue // Skip interfaces without addresses or errors fetching them
		}

		names = append(names, i.Name)
	}

	if len(names) == 0 {
		slog.Warn("No suitable non-loopback, active network interfaces found.")
		// Return empty list, not an error
	}
	return names, nil
}

// GetUidFromPid reads the UID from the /proc filesystem for a given PID.
func GetUidFromPid(pid uint32) (uint32, error) {
	statusFilePath := fmt.Sprintf("/proc/%d/status", pid)
	data, err := os.ReadFile(statusFilePath)
	if err != nil {
		// Process likely exited
		if errors.Is(err, os.ErrNotExist) {
			return 0, fmt.Errorf("process %d not found (likely exited): %w", pid, err)
		}
		return 0, fmt.Errorf("failed to read process status file %s: %w", statusFilePath, err)
	}

	// Parse the status file line by line
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Uid:") {
			fields := strings.Fields(line) // Split by whitespace
			// Expecting "Uid:\t<RealUID>\t<EffectiveUID>\t<SavedUID>\t<FilesystemUID>"
			if len(fields) >= 2 {
				// Use the Real UID (first numeric field)
				uidVal, err := strconv.ParseUint(fields[1], 10, 32)
				if err != nil {
					return 0, fmt.Errorf("failed to parse Real UID from status line '%s': %w", line, err)
				}
				return uint32(uidVal), nil // Success
			}
		}
	}

	// UID line not found in the status file
	return 0, fmt.Errorf("uid not found in process status file %s", statusFilePath)
}
